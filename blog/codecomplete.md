Title:   代码大全
Brief:   Code Complete《代码大全》，经典著作书摘，主要关于软件工程，如何构建软件，如何编写代码，应该有什么样的编程风格。
Authors: Jin Jay
image:  images/levelsOfDesign.png
Date:    2014-10
keywords: code complete
          代码大全


# 代码大全
## 需求
应付客户提出的新功能：“咦，这听起来是一个很不错的主意。不过由于它不是需求文档里的内容，我会整理一份修订过的进度表和成本估计表，这样你可以决定是现在实施，还是过一阵子再说。”

## 架构
### 架构设计的重要意义
> 如果你要盖一个简单的建筑物--比如一个狗屋--你只需要去木材店买一些木头和钉子，一个下午就做好了，如果你忘了弄一个门，或是犯了什么错误，那也没什么大不了的，修改一下或者干脆从头再来就是了。你的损失也就是一个下午的时间。如果你写1000行代码时采用了错误的设计，你还可以重构甚至从头再来，不会损失太多。  
>   
> 如果你是在建一栋房子，那么这个建造过程就会复杂得多，而糟糕的设计所引发的后果也更严重。狗屋与房子建造的重要区别就在于设计蓝图，也就是软件的架构设计上。

精心计划，并非意味着事无巨细的计划或者过度的计划。你可以把房屋结构性的支撑规划清楚，而在日后再决定是用木地板还是地毯。

### 架构的典型组成部分
1. 程序组织（Program Organnization），也即模块结构
2. 主要的类（Major Classes）
3. 数据设计（Data Design）
4. 用户界面设计（User Interface Design）
5. 资源管理（Resource Management）:预期的实现环境等
6. 安全性（Security）
7. 性能（Performance）
8. 可伸缩性（Scalability）:系统增长以满足未来需求的能力。如用户数量、服务器数量、网络节点数量、数据库记录数、数据库记录的长度等得增长
9. 互用性（Interoperability）:系统与其他软件或硬件共享数据或资源
10. 国际化/本地化（Internationality/Localization）
11. 输入输出（Input/Output）
12. 错误处理（Error Handling）
13. 容错性（Fault Tolerance）
14. 可行性（Feasibility）
15. 过度工程（Overengineering）
16. 买还是造决策（Buy-vs.-Build Decisions）:购买组件还是自己定制
17. 复用（Reuse）
18. 变更策略（Change Strategy）
19. 总体质量（General Architectural Quality）

架构设计不能有二义性，需要很清楚的描述出来。
> 如果你不能向一个六岁的小孩解释某件事，那么你自己就没有真正理解它。
> ——Albert Einstein （爱因斯坦）

## 设计
### 关键的设计概念
***软件的首要技术使命是管理复杂度。***
> 有两种设计软件的方式：一种方法是让设计非常简单，看上去明显没有缺陷；另一种方法是让设计非常复杂，看上去没有明显缺陷。
> ——C.A.R Hoare

> 你已陷入复杂度的沼泽的一个现象就是，你发现自己顽固地用一种明显毫无作用的方法——至少在外人眼里。这就像是一个遇到车子抛锚的蠢货一样——他把水放到电池里然后把烟灰缸倒掉。
> ——P.J. Plauger

### 理想的设计特征
1. 最小的复杂度（Minimal complexity）
2. 易于维护（Ease of maintenance）
3. 松散耦合（loose coupling）
4. 可扩展性（extensibility）
5. 可重用性（reusability）
6. 高扇入（high fan-in）:让大量的类使用某个给定的类，即利用在较低层次上的工具类
7. 低扇出（low fan-out）:让一个类里少量或适中的使用其他的类
8. 可移植性（portability）
9. 精简性（leanness）:系统中没有多余的部分
10. 层次性（stratification）:系统应该能在任一层次上观察而不需要进入其他层次
11. 标准技术（Standard techniques）:尽量使用标准化的、常用的方法

### 设计的层次
<img src="../../images/levelsOfDesign.png">
系统首先被组织为子系统。子系统被进一步分解为类，然后类又被分解为子程序和数据。每个子程序的内部也需要进行设计。

### 启发式设计
· 寻找现实设计的对象  
· 形成一致的抽象  
· 封装实现的细节  
· 在可能的情况下继承  
· 信息隐藏  
· 找出容易改变的区域  
· 保持松散耦合  
· 探寻通用的设计模式  
#### 使用启发式方法的原则
G·波利亚《怎样解题》（《How to Solve It》，1957）

```
1. 理解问题。
    未知量是什么？现有的数据是什么？条件是什么？
2. 设计一个计划。找出现有数据和未知量之间的联系。如果你找不出其中的联系，那么可能还得考虑些辅助性的问题。
    在此之前你遇见过这一问题吗？或者曾经遇见过与此差别不大的问题？
    你使用了全部的数据吗？使用了全部的条件？考虑了该问题所涉及的所有核心概念了没？
3. 执行着一个计划
    执行你的求解计划，检查每一步。确定每一步都是正确的吗？
4. 回顾
    核对结果，核对论据，考虑能不能用其他方法来得出这个结果？你能一眼看出来吗？你能在其它问题上使用这一结果或方法吗？
```

### 设计实践
> 设计是一种迭代过程，你并非只能从A点进行到B点，而是可以从A点到达B点，再从B点返回到A点。

1. **分而治之**  
  把程序分解为不同的关注区域，然后分别处理每一个区域。  
2. **自上而下和自下而上的设计方法**  
  自上而下的设计从某个很高的抽象层次开始。自下而上的设计始于细节，向一般性延伸。前者是一种分解策略，后者是一种合成策略。  
3. **建立实验性原型**  
  原型能够帮助理解系统，但需要注意“写出用于回答特定设计问题的、量最少且能够随时扔掉的代码”。  
4. **合作设计**  
  三个臭皮件顶得上一个诸葛亮。  
5. **适当设计**  
  设计不能太精简也不能太过度，具体的项目有具体的要求，要做到适度设计。  
6. **记录设计成果**  
  写Wiki，写总结邮件，保留设计挂图，使用CRC(类、职责、合作者)卡片，在适当的细节层创建UML图。

## 类
### 良好的类接口
1. 提供成对的服务
2. 把不相关的信息转移到其他类中
3. 尽可能让接口可编程，而不是表达语义
    每个接口都有一个可编程的部分和一个与一部分组成。可编程部分由接口中的数据类型和其他属性组成，而语义部分则由“本接口将怎样被使用”的假定组成。
4. 谨防在修改时破坏接口的抽象

> 每当你发现自己是通过查看类的内部实现来得知该如何使用这个类的时候，你就不是在针对接口编程了，而是透过接口正对内部实现编程了。


### 良好的封装
1. 尽可能地限制类和成员的可访问性
2. 不要公开暴露成员数据
3. 避免把私用的实现细节放入类的接口中
4. 不要对类的使用者做出任何假设
5. 避免使用友元类
6. 让阅读代码比编写代码更方便
7. 要格外警惕从语义上破坏封装性

> 不知道怎样去使用一个类时，应告诉类的开发者，让开发者check out，修改接口文档后check in，然后告诉你“看看现在你知不知道该怎么用它了”。

### 类的设计与实现
1. **包含关系（has a）**  
    警惕超过7个数据成员的类，人们在做其他事情时能记住的离散项目的个数是$7 \pm 2$。如果一个类包含超过7个数据成员，考虑把它分解为几个更小的类。
2. **继承（is a）**
    要么使用继承并进行详细说明，要么就不要用它。  
    遵循Liskove替换原则——派生类必须能通过基类的接口而被使用，且使用者无需了解两者之间的差异。  
    避免让继承体系过深。
    只要一个实例的类、只有一个派生类的基类都值得怀疑。
    尽量使用多态，避免大量的类型检查。
3. **成员函数和数据成员**
    让类中的子程序数量尽可能少。
    禁止隐式地产生你不需要的成员函数和运算符。
    减少类所调用的不同子程序的数量。
    对其他类的子程序的简介调用要尽可能少。
4. **构造函数**
    如果可能，应该在所有的构造函数中初始化所有的数据成员。
    用私用（private）构造函数来强制实现单例属性。
    优先采用深层副本，除非论证可行，才采用浅层副本。[对象的深层副本是对象成员数据逐项赋值的结果;而浅层副本则往往只是指向或引用同一个实际对象]

### 类的作用
> 为现实世界建模  
降低和隔离复杂度  
隐藏实现细节和全局数据  
让参数传递更顺畅让代码更易于重用  
把相关操作包装到一起  
实现某种特定的结构

### 避免创建的类
**避免创建万能类**  
**消除无关紧要的类**  
**避免用动词命名的类**

## 子程序
按照输入-参数-输出的顺序排列参数。  
把子程序的参数个数限制在大约7个以内。  
宏子程序：用大括号括起含有多条语句的宏。

## 防御式编程
### 保护程序免遭非法输入数据的破坏
1. 检查所有来源于外部的数据的值
2. 检查子程序所有输入参数的值
3. 决定如何处理错误的输入数据

### 断言
断言是指在 *开发期间* 使用的、让程序在运行时进行自检的代码（通常是一个子程序或宏）。  
1. 用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况
2. 避免把需要执行的代码放到断言中
3. 用断言来注解并验证前条件和后条件
    前条件是子程序或类在调用子程序或实例化对象之前要确保为真的属性。
    后条件是子程序或类在执行结束后要确保为真的属性。
4. 对于高健壮性的代码，应该先使用断言再处理错误

### 错误处理
1. 返回中立值
2. 换用下一个正确的数据
3. 返回与前次相同的数据
4. 换用最接近的合法值
5. 把警告信息记录到日志文件中
6. 返回一个错误码
7. 调用错误处理子程序或对象
8. 当错误发生时显示出错消息
9. 关闭程序

### 异常
异常是把代码中的错误或异常事件传递给调用方代码的一种特殊手段。
1. 只有在真正例外的情况下才抛出异常
2. 避免在构造函数和析构函数中抛出异常，除非你在同一地方把它们破获
3. 在宜昌消息中加入关于导致异常发生的全部信息
4. 考虑创建一个集中的异常报告机制

## 伪代码
### 通过伪代码编程过程创建子程序
1. 检查先决条件
2. 定义子程序要解决的问题
3. 为子程序命名
4. 决定如何测试子程序
5. 在标准库中搜寻可用的功能
6. 考虑错误处理
7. 考虑效率问题
8. 研究算法和数据结构
9. 编写伪代码
10. 考虑数据
11. 检查伪代码
12. 在伪代码中试验一些想法，留下最好的想法（迭代）

### 编写子程序的代码
<img src="../../images/pseudocode.png">






# 未完待续...


[TOC]
