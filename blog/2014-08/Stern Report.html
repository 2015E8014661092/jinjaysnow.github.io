<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'/>
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Jinjaysnow.github.io : created for blog" />
    <link rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="../../stylesheets/blog.css">
    <!-- <link rel="stylesheet" type="text/css" href="../../stylesheets/pygment_trac.css"> -->
    <link rel="stylesheet" type="text/css" href="../../stylesheets/pygment1.css">
    <title>Stern Report</title>
    <link rel="shortcut icon" href="../../images/bitbug_favicon.ico" />
  </head>
  <body>
  	<h1>实习内容记述</h1>
<p>2014年 6月 17号到7月 11号，在大连东软集团实习。</p>
<h2>实习任务</h2>
<p>经过30多个小时的车程后，在18号下午到达了东软集团，路途比较长，下午在安排的员工宿舍休息。在到达东软集团的第二天，见到了实习经理，他给我们介绍了一下此次实习的日程安排：</p>
<div class="codehilite"><pre><span class="err">前期学习</span> <span class="n">Linux</span><span class="err">环境编程和系统编程。</span>
<span class="err">根据所学制作一款局域网聊天软件或邮件系统软件。</span>
</pre></div>


<h2>实习过程</h2>
<p>从到东软的第二天开始，先是学习在 Windows电脑上的 Vmware虚拟机软件中安装 Ubuntu系统。然后是熟悉Linux环境编程。接触到了一些常用命令<code>ls</code>, <code>ps</code>, <code>top</code>, <code>kill</code>, <code>grep</code>, <code>find</code>, <code>man</code>, <code>cd</code>, <code>rm</code>, <code>cp</code>, <code>locate</code>, <code>which</code>, <code>what</code>, <code>whatis</code>, <code>where</code>, <code>whereis</code>... 还有管道操作<code>|</code>，重定向操作<code>&lt;</code>和<code>&gt;</code>等等。每一个命令都会练习使用好几遍以达到熟悉的程度。<br />
Linux系统编程从介绍 Vim编辑器开始，然后是 gcc编译器的使用， gdb调试工具的使用， makefile的编写，最后是系统函数调用(系统编程)的学习。<br />
6月 28号开始了小组分配和项目编写。我们小组总共8个人，其中一个项目经理，一个评审负责人，一个配置管理员。我是小组评审负责人，主要负责项目的设计评审、技术点分析，同时还是服务器端的编程人员。小组选择了聊天软件项目。</p>
<h1>专题内容分析</h1>
<h2>Linux环境编程学习</h2>
<h3>Shell脚本与常用命令</h3>
<blockquote>
<p>man命令<br />
格式化显示在线操作手册。在实习中遇到不会用的命令还有系统编程时不会使用的函数时，通过man命令能够很快速的找到有用的信息，十分好用。例如：</p>
</blockquote>
<div class="codehilite"><pre><span class="n">man</span> <span class="n">ls</span> <span class="err">#</span> <span class="err">查看</span><span class="n">ls</span><span class="err">命令的帮助信息</span>
</pre></div>


<p><img src="http://jinjaysnow.github.io/images/manls.png"></p>
<blockquote>
<p>其他常用命令</p>
</blockquote>
<div class="codehilite"><pre><span class="n">cd</span> <span class="p">..</span>           <span class="err">#</span> <span class="err">改变位置到父目录</span>
<span class="n">cd</span> <span class="o">~</span>            <span class="err">#</span> <span class="err">改变位置到用户工作目录</span>
<span class="n">cp</span> <span class="n">file1</span> <span class="n">file2</span>  <span class="err">#</span> <span class="err">将文件</span><span class="n">file1</span><span class="err">复制到</span><span class="n">file2</span>
<span class="n">mv</span> <span class="n">file1</span> <span class="n">file2</span>  <span class="err">#</span> <span class="err">将文件</span><span class="n">file1</span><span class="err">更名为</span><span class="n">file2</span>
<span class="n">mkdir</span> <span class="n">dir1</span>      <span class="err">#</span> <span class="err">建立一个目录</span><span class="n">dir1</span>
<span class="n">rm</span> <span class="n">f</span><span class="o">*</span>           <span class="err">#</span> <span class="err">删除当前所有以</span><span class="n">f</span><span class="err">开头的文件</span>
<span class="n">rm</span> <span class="o">-</span><span class="n">r</span> <span class="n">dir1</span>      <span class="err">#</span> <span class="err">删除目录</span><span class="n">dir1</span><span class="err">及其子目录下所有文件</span>
<span class="n">cat</span> <span class="n">file1</span>       <span class="err">#</span> <span class="err">打印文件内容到屏幕</span>
<span class="n">pwd</span>             <span class="err">#</span> <span class="err">列出当前所在的目录信息</span>
<span class="n">chmod</span> <span class="n">mode</span> <span class="n">file</span> <span class="err">#</span> <span class="err">改变文件的读写执行权限</span>
</pre></div>


<h3>管道 <code>|</code></h3>
<p><em>语法：</em> 命令1 | 命令2<br />
将命令1的执行结果送给命令2，作为命令2的输入。<br />
管道使得两个及多个命令可以相互通信，带来了很多的便利。</p>
<div class="codehilite"><pre><span class="n">ls</span> <span class="o">-</span><span class="n">R1</span> <span class="o">|</span> <span class="n">more</span>   <span class="err">#</span> <span class="err">以分页的方式列出当前目录及其子目录下所有文件的名称</span>
</pre></div>


<h3>输入输出重定向<code>&lt;</code> &amp; <code>&gt;</code></h3>
<p><em>语法：</em> 命令 <code>&lt;</code> 文件<br />
将文件作为命令的输入。
<em>语法：</em> 命令 <code>&gt;</code> 文件<br />
将命令的结果送至指定的文件。<br />
输入输出重定向便于将操作的结果送入文件或读取文件作为操作的输入。</p>
<div class="codehilite"><pre><span class="n">mail</span> <span class="o">-</span><span class="n">s</span> <span class="s">&quot;theme&quot;</span> <span class="n">xx</span><span class="err">@</span><span class="n">email</span><span class="p">.</span><span class="n">com</span> <span class="o">&lt;</span> <span class="n">file1</span> <span class="err">#</span> <span class="err">将文件</span><span class="n">file1</span><span class="err">当做信件内容发给收件人</span>
<span class="n">ls</span> <span class="o">-</span><span class="n">l</span> <span class="o">&gt;</span> <span class="n">list</span>    <span class="err">#</span> <span class="err">将”</span><span class="n">ls</span> <span class="o">-</span><span class="n">l</span><span class="err">“的结果写入文件</span><span class="n">list</span>
</pre></div>


<h2>Linux系统编程</h2>
<h3>Vim编辑器</h3>
<p>Vim是从vi发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富。Vim拥有多种模式，常用有三种：</p>
<blockquote>
<p>普通模式<br />
在普通模式中，用的是编辑器命令，比如移动光标，删除文本等等。这是Vim启动后的默认模式。常用命令有：</p>
</blockquote>
<div class="codehilite"><pre><span class="n">j</span>   <span class="err">#</span> <span class="err">光标向上移动一行</span>
<span class="n">k</span>   <span class="err">#</span> <span class="err">光标向下移动一行</span>
<span class="n">h</span>   <span class="err">#</span> <span class="err">光标向左移动一个字符</span>
<span class="n">l</span>   <span class="err">#</span> <span class="err">光标向右移动一个字符</span>
<span class="n">w</span>   <span class="err">#</span> <span class="err">光标移到下一个单词词首</span>
<span class="n">e</span>   <span class="err">#</span> <span class="err">光标移到单词末尾或下一个单词末尾</span>
<span class="n">b</span>   <span class="err">#</span> <span class="err">光标回退到词首或回退到上一个单词词首</span>
<span class="n">dd</span>  <span class="err">#</span> <span class="err">删除一行</span>
<span class="n">daw</span> <span class="err">#</span> <span class="err">删除当前光标所在单词</span>
<span class="n">r</span>   <span class="err">#</span> <span class="err">替换一个字符</span>
<span class="n">x</span>   <span class="err">#</span> <span class="err">删除当前光标所在的一个字符</span>
<span class="n">G</span>   <span class="err">#</span> <span class="err">跳转到文章末尾</span>
<span class="n">gg</span>  <span class="err">#</span> <span class="err">跳转到文章开头</span>
</pre></div>


<blockquote>
<p>插入模式<br />
在普通模式中，有很多方法可以进入插入模式。常用的方式是按"a"（append／追加）键或者"i"（insert／插入）键。在这个模式中，大多数按键都会向文本缓冲中插入文本。在插入模式中，可以按ESC键回到普通模式。</p>
<p>可视模式<br />
这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的"文本对象"也能和移动命令一样用在这个模式中。</p>
</blockquote>
<div class="codehilite"><pre><span class="n">y</span>   <span class="err">#</span> <span class="err">复制高亮选中的文本</span>
<span class="n">p</span>   <span class="err">#</span> <span class="err">粘贴复制在缓冲区的文本</span>
</pre></div>


<blockquote>
<p>Vim文件配置</p>
</blockquote>
<div class="codehilite"><pre><span class="err">#</span> <span class="err">定义</span><span class="nx">F5</span><span class="err">键用于构建并运行</span><span class="nx">c</span><span class="err">文件</span>
<span class="kt">map</span> <span class="o">&lt;</span><span class="nx">F5</span><span class="o">&gt;</span> <span class="p">:</span><span class="nb">call</span> <span class="nx">Compilerungcc</span><span class="p">()</span> <span class="o">&lt;</span><span class="nx">CR</span><span class="o">&gt;</span>
<span class="nx">func</span><span class="o">!</span> <span class="nx">Compilerungcc</span><span class="p">()</span>
<span class="nx">exec</span> <span class="s2">&quot;w&quot;</span>
<span class="nx">exec</span> <span class="s2">&quot;!gcc % -o %c&quot;</span>
<span class="nx">exec</span> <span class="s2">&quot;! ./%&lt;&quot;</span>
<span class="nx">endfunc</span>
</pre></div>


<h3>GCC</h3>
<p>GCC（GNU Compiler Collection，GNU编译器套装），是一套由GNU开发的编程语言编译器。</p>
<div class="codehilite"><pre><span class="n">gcc</span> <span class="o">-</span><span class="n">E</span> <span class="n">hello</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span><span class="p">.</span><span class="n">i</span>   <span class="err">#</span> <span class="err">预处理</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">S</span> <span class="n">hello</span><span class="p">.</span><span class="n">i</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span><span class="p">.</span><span class="n">s</span>   <span class="err">#</span> <span class="err">编译</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">c</span> <span class="n">hello</span><span class="p">.</span><span class="n">s</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span><span class="p">.</span><span class="n">o</span>   <span class="err">#</span> <span class="err">汇编</span>
<span class="n">gcc</span> <span class="n">hello</span><span class="p">.</span><span class="n">o</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span>        <span class="err">#</span> <span class="err">链接</span>
</pre></div>


<p><strong>gcc参数</strong><br />
<code>gcc -I目录 -l链接库 -L链接库路径</code></p>
<p><strong>gcc生成链接库</strong>  </p>
<div class="codehilite"><pre><span class="cp"># 静态链接库</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">c</span> <span class="n">source</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">source</span><span class="p">.</span><span class="n">o</span>             <span class="err">#</span> <span class="err">生成</span><span class="p">.</span><span class="n">o</span><span class="err">文件</span>
<span class="n">ar</span> <span class="n">rcs</span> <span class="o">-</span><span class="n">o</span> <span class="n">libsource</span><span class="p">.</span><span class="n">a</span> <span class="n">source</span><span class="p">.</span><span class="n">o</span>          <span class="err">#</span> <span class="n">ar</span><span class="err">命令将</span><span class="p">.</span><span class="n">o</span><span class="err">文件打包成静态库文件</span>
<span class="n">ar</span> <span class="n">t</span> <span class="n">libsource</span><span class="p">.</span><span class="n">a</span>                        <span class="err">#</span> <span class="err">查看</span><span class="n">libsource</span><span class="p">.</span><span class="n">a</span><span class="err">包含哪些文件</span> 
<span class="cp"># 动态链接库</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">c</span> <span class="n">source</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">fpic</span> <span class="o">-</span><span class="n">o</span> <span class="n">source</span><span class="p">.</span><span class="n">o</span>       <span class="err">#</span> <span class="err">添加</span><span class="o">-</span><span class="n">fpic</span><span class="err">选项生成</span><span class="p">.</span><span class="n">o</span><span class="err">文件</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">shared</span> <span class="n">source</span><span class="p">.</span><span class="n">o</span> <span class="o">-</span><span class="n">o</span> <span class="n">libsource</span><span class="p">.</span><span class="n">so</span>    <span class="err">#</span> <span class="err">生成动态链接库</span>
</pre></div>


<h3>Makefile</h3>
<blockquote>
<p>在软件开发中，make是一个工具程序（Utility software），它是一种转化文件形式的工具，转换的目标称为“target”；与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。大多数情况下，make被用来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。<em>makefile</em>便是make用来确定一个target文件的依赖关系，然后把生成这个target的相关命令传给shell去执行的文件。</p>
</blockquote>
<div class="codehilite"><pre><span class="cp"># makefile预定义变量</span>
<span class="err">$@</span> <span class="err">目标名称</span>
<span class="err">$</span><span class="o">^</span> <span class="err">所有被依赖的对象</span>
<span class="err">$</span><span class="o">&lt;</span> <span class="err">第一个被依赖的文件</span>
<span class="cp"># 模式规则</span>
<span class="o">%</span><span class="p">.</span><span class="n">o</span><span class="o">:</span> <span class="o">%</span><span class="p">.</span><span class="n">c</span>  <span class="err">#</span> <span class="err">将所有的</span><span class="p">.</span><span class="n">c</span><span class="err">文件生成</span><span class="p">.</span><span class="n">o</span><span class="err">文件，</span> <span class="o">%</span><span class="err">是通配符</span>
<span class="cp"># 使用</span>
<span class="n">cc</span> <span class="err">$</span><span class="p">(</span><span class="n">CCFLAGS</span><span class="p">)</span> <span class="o">-</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="err">$@</span> <span class="err">$</span><span class="o">&lt;</span>
</pre></div>


<h3>GDB调试工具</h3>
<p>GNU调试器(Debugger，缩写：GDB)，是GNU软件系统中的标准调试器。</p>
<div class="codehilite"><pre><span class="n">gcc</span> <span class="o">-</span><span class="n">c</span> <span class="n">source</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">source</span> <span class="o">-</span><span class="n">g</span>    <span class="err">#</span> <span class="err">在编译时使用</span><span class="o">-</span><span class="n">g</span><span class="err">选项</span>
<span class="n">list</span>    <span class="err">#</span> <span class="err">显示代码</span>
<span class="k">break</span>   <span class="err">#</span> <span class="err">设置断点</span>
<span class="n">watch</span>   <span class="err">#</span> <span class="err">观察变量，变量值改变时输出值</span>
<span class="n">print</span>   <span class="err">#</span> <span class="err">查看变量信息</span>
<span class="n">step</span>    <span class="err">#</span> <span class="err">在断点时，用于一步一步继续执行，进入函数内部</span>
<span class="n">next</span>    <span class="err">#</span> <span class="err">在断电时，继续执行但不进入函数内部</span>
</pre></div>


<h3>系统编程</h3>
<blockquote>
<p>系统编程：从操作系统获得服务或资源而向内核发起的函数调用。</p>
</blockquote>
<h4>文件和文件系统</h4>
<p>在Linux系统中一切皆是文件，很多交互工作是通过读取和写入文件件来完成的。<br />
文件通过inode（信息节点）访问，inode使用唯一的数值（inode编号）进行标识。一个inode存储文件关联的元数据，如它的修改时间戳、所有者、类型、长度以及文件的数据的地址--不包含文件名。目录将易读的文件名与inode编号进行映射。文件名与inode的配对也称为链接（link）。<br />
用户请求打开一个文件时，内核打开包含指定文件名的目录然后搜索该文件。内核通过文件名获得inode编号，然后根据inode编号找到对应的inode。</p>
<div class="codehilite"><pre><span class="c1">// open() 打开文件</span>
<span class="p">#</span><span class="k">include</span> <span class="o">&lt;</span><span class="n">fcntl</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="k">int</span> <span class="n">open</span> <span class="p">(</span><span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">int</span> <span class="n">flags</span><span class="p">,</span> <span class="p">...);</span>
<span class="c1">// flags: O_RDONLY, O_WRONLY, O_RDWR</span>
<span class="c1">// 打开文件错误时会返回-1，成功则返回文件描述符</span>
</pre></div>


<div class="codehilite"><pre><span class="c1">// read() 读取文件</span>
<span class="p">#</span><span class="k">include</span> <span class="o">&lt;</span><span class="n">unistd</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="n">ssize_t</span> <span class="n">read</span> <span class="p">(</span><span class="k">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">void</span> <span class="o">*</span><span class="k">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="c1">// 从文件fd的当前偏移量至多读取len个字节到buf中，成功时返回写入buf中的字节数，出错返回-1</span>
</pre></div>


<div class="codehilite"><pre><span class="c1">// write() 写入文件</span>
<span class="p">#</span><span class="k">include</span> <span class="o">&lt;</span><span class="n">unistd</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="n">ssize_t</span> <span class="n">write</span> <span class="p">(</span><span class="k">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="k">void</span> <span class="o">*</span><span class="k">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="c1">// 从文件fd当前位置开始将buf中至多count个字节写入文件中</span>
</pre></div>


<div class="codehilite"><pre><span class="c1">// close() 关闭文件</span>
<span class="p">#</span><span class="k">include</span> <span class="o">&lt;</span><span class="n">unistd</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="k">int</span> <span class="n">close</span><span class="p">(</span><span class="k">int</span> <span class="n">fd</span><span class="p">);</span>
<span class="c1">// 解除文件描述符的关联，并分离进程和文件的关联</span>
</pre></div>


<div class="codehilite"><pre><span class="c1">// 其他调用</span>
<span class="n">off_t</span> <span class="n">lseek</span><span class="p">(</span><span class="k">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">pos</span><span class="p">,</span> <span class="k">int</span> <span class="n">origin</span><span class="p">);</span>     <span class="c1">// 移动读写指针</span>
<span class="p">#</span><span class="k">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">stat</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>                           <span class="c1">// 查看文件属性</span>
<span class="k">int</span> <span class="n">fstat</span><span class="p">(</span><span class="k">int</span> <span class="n">fildes</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="k">buf</span><span class="p">);</span>
<span class="k">int</span> <span class="n">lstat</span><span class="p">(</span><span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="k">restrict</span> <span class="k">buf</span><span class="p">);</span>
<span class="k">int</span> <span class="n">stat</span><span class="p">(</span><span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="k">restrict</span> <span class="k">buf</span><span class="p">);</span>
<span class="c1">// 制作文件硬链接</span>
<span class="k">int</span> <span class="n">link</span><span class="p">(</span><span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">path1</span><span class="p">,</span> <span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">path2</span><span class="p">);</span>
<span class="c1">// 制作符号链接</span>
<span class="k">int</span> <span class="n">symlink</span><span class="p">(</span><span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">path1</span><span class="p">,</span> <span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">path2</span><span class="p">);</span>
</pre></div>


<h4>信号与信号处理</h4>
<p>信号是提供处理异步事件机制的软件终端。信号有一个明确的生命周期：首先，产生信号；然后内核存储信号直到可以发送它；最后，一旦有空闲，内核会适当的处理信号。信号处理通常有三种情况：</p>
<ol>
<li><strong>忽略信号</strong>  不采取任何操作。信号SIGKILL和SIGSTOP不能忽略。</li>
<li><strong>捕获并处理信号</strong>  内核会暂停该进程正在执行的代码，并跳转到先前注册过的函数。接下来进程执行该函数，执行完后再跳回先前捕获信号的地方继续执行。常见的有SIGINT和SIGTERM。</li>
<li><strong>执行默认操作</strong>  取决于被发送的信号。默认操作通常是终止进程。</li>
</ol>
<div class="codehilite"><pre><span class="cp">#include &lt;signal.h&gt;</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">int</span><span class="p">)))(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="kt">sig_t</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">sig_t</span> <span class="nf">signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="kt">sig_t</span> <span class="n">func</span><span class="p">);</span>
<span class="c1">// sig: 信号种类 func: 接收到信号后调用的函数，参数是被处理信号的标识符</span>
<span class="kt">int</span> <span class="nf">sigaction</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sigaction</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">act</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sigaction</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">oact</span><span class="p">);</span>
<span class="c1">// 设置信号处理动作，signal()不带信号信息，sigaction()带有额外的信号信息</span>
</pre></div>


<h4>进程与线程</h4>
<p><strong>进程管理</strong><br />
进程是程序实体的一次运行，是系统进行资源分配和调度的一个基本独立单位。每一个进程都有一个唯一的标识符，即进程ID，简称pid。系统保证某时刻每个pid都是唯一的。</p>
<div class="codehilite"><pre><span class="c1">// 获得进程ID</span>
<span class="p">#</span><span class="k">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">types</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="p">#</span><span class="k">include</span> <span class="o">&lt;</span><span class="n">unistd</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="n">pid_t</span> <span class="n">getpid</span><span class="p">(</span><span class="k">void</span><span class="p">);</span>     <span class="c1">// 返回调用进程的ID</span>
<span class="n">pid_t</span> <span class="n">getppid</span><span class="p">(</span><span class="k">void</span><span class="p">);</span>    <span class="c1">// 返回进程的父进程ID</span>
<span class="c1">// 创建进程</span>
<span class="n">pid_t</span> <span class="k">fork</span><span class="p">(</span><span class="k">void</span><span class="p">);</span>       <span class="c1">// 父子进程不共享数据，随机运行，返回0给子进程pid_t</span>
<span class="n">pid_t</span> <span class="n">vfork</span><span class="p">();</span>          <span class="c1">// 父子进程共享数据，子进程先运行</span>
<span class="c1">// exec系列系统调用</span>
<span class="k">int</span> <span class="n">execl</span><span class="p">(</span><span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">arg0</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/*, (char *)0 */</span><span class="p">);</span>
<span class="c1">// 将path所指路径的映像载入内存，替换当前进程的映像。execl是可变参数的，但参数列表必须以NULL(0)结尾</span>
<span class="c1">// 终止进程</span>
<span class="k">void</span> <span class="n">exit</span><span class="p">(</span><span class="k">int</span> <span class="n">status</span><span class="p">);</span>
<span class="k">int</span> <span class="n">kill</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">int</span> <span class="n">sig</span><span class="p">);</span>
</pre></div>


<p><strong>线程</strong><br />
线程是一个“轻量级的进程”。线程自己不拥有系统资源，引入线程后进程只作为除CPU外系统资源的分配单元，线程则作为处理机的分配单元，即线程是独立调度的基本单位，进程是资源拥有的基本单位。</p>
<div class="codehilite"><pre><span class="cp">#include &lt;pthread.h&gt;</span>
<span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span> <span class="k">const</span> <span class="kt">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="c1">// 线程创建, thread: 线程标识符  attr: 线程属性(堆栈大小) start_routine: 线程调用的函数 arg: 函数参数</span>
<span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value_ptr</span><span class="p">);</span> <span class="c1">// 线程退出</span>
<span class="c1">// 线程信号量同步</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">mutex</span><span class="p">,</span> <span class="k">const</span> <span class="kt">pthread_mutexattr_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">attr</span><span class="p">);</span>  
<span class="kt">int</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</pre></div>


<p><strong>进程间通信</strong><br />
IPC（InterProcess Communication）函数提供了系统中多个进程之间相互通信的方法。Linux系统中包含以下几种方式的IPC：</p>
<ol>
<li>半双工Unix管道pipe</li>
<li>FIFO(命名管道)</li>
<li>消息队列</li>
<li>信号量机制</li>
<li>共享内存</li>
<li>socket网络套接字</li>
</ol>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">fildes</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>    <span class="c1">// pipe用于父子进程之间，如果父进程从子进程中读取数据，则父进程应关闭fd1，同时子进程关闭fd0；反之，父进程向子进程发送数据，它应该关闭fd0，子进程关闭fd1。</span>
<span class="kt">int</span> <span class="nf">mkfifo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">mode_t</span> <span class="n">mode</span><span class="p">);</span>  <span class="c1">// 创建一个命名管道，用于不同程序之间</span>
</pre></div>


<div class="codehilite"><pre><span class="c1">// 消息队列</span>
<span class="p">#</span><span class="k">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">ipc</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="p">#</span><span class="k">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">msg</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="k">int</span> <span class="n">msgget</span><span class="p">(</span><span class="n">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="k">int</span> <span class="n">msgflg</span><span class="p">);</span>  <span class="c1">// 创建或获取一个消息队列 msgflg通常为IPC_CREAT | IPC_EXCL</span>
<span class="k">int</span> <span class="n">msgsnd</span><span class="p">(</span><span class="k">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msgbuf</span> <span class="o">*</span><span class="n">msgp</span><span class="p">,</span> <span class="k">int</span> <span class="n">msgsz</span><span class="p">,</span> <span class="k">int</span> <span class="n">msgflg</span><span class="p">);</span> <span class="c1">// 向消息队列发送消息</span>
<span class="k">int</span> <span class="n">msgctl</span><span class="p">(</span><span class="k">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="k">int</span> <span class="n">cmd</span><span class="p">,</span>  <span class="k">struct</span> <span class="n">msqid_ds</span> <span class="o">*</span><span class="k">buf</span><span class="p">);</span> <span class="c1">// 控制对消息队列的操作</span>
<span class="k">int</span> <span class="n">msgrcv</span><span class="p">(</span><span class="k">int</span>  <span class="n">msqid</span><span class="p">,</span> <span class="k">void</span> <span class="o">*</span><span class="n">msgp</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">msgsz</span><span class="p">,</span> <span class="n">long</span> <span class="n">msgtyp</span><span class="p">,</span> <span class="k">int</span> <span class="n">msgflg</span><span class="p">);</span> <span class="c1">// 接收消息队列消息</span>
<span class="c1">// 信号量机制</span>
<span class="p">#</span><span class="k">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">sem</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="k">int</span> <span class="n">semget</span><span class="p">(</span><span class="n">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="k">int</span> <span class="n">nsems</span><span class="p">,</span> <span class="k">int</span> <span class="n">semflg</span><span class="p">);</span> <span class="c1">// 创建或获取一个信号量</span>
<span class="k">int</span> <span class="n">semop</span><span class="p">(</span><span class="k">int</span> <span class="n">semid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span><span class="n">sops</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">nsops</span><span class="p">);</span> <span class="c1">// 信号量操作</span>
<span class="k">int</span> <span class="n">semctl</span><span class="p">(</span><span class="k">int</span> <span class="n">semid</span><span class="p">,</span> <span class="k">int</span> <span class="n">semnum</span><span class="p">,</span> <span class="k">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...);</span> <span class="c1">// 信号量控制</span>
<span class="c1">// 共享内存</span>
<span class="p">#</span><span class="k">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">shm</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="k">int</span> <span class="n">shmget</span><span class="p">(</span><span class="n">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">int</span> <span class="n">flags</span><span class="p">);</span> <span class="c1">// 创建或获取一段共享内存</span>
<span class="k">void</span> <span class="o">*</span><span class="n">shmat</span><span class="p">(</span><span class="k">int</span> <span class="n">shmid</span><span class="p">,</span> <span class="k">const</span> <span class="k">void</span> <span class="o">*</span><span class="n">shmaddr</span><span class="p">,</span> <span class="k">int</span> <span class="n">shmflg</span><span class="p">);</span> <span class="c1">// 将共享内存段连接到进程中的地址</span>
<span class="k">int</span> <span class="n">shmctl</span><span class="p">(</span><span class="k">int</span> <span class="n">shmid</span><span class="p">,</span> <span class="k">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">shmid_ds</span> <span class="o">*</span><span class="k">buf</span><span class="p">);</span> <span class="c1">// 内存控制</span>
<span class="k">int</span> <span class="n">shmdt</span><span class="p">(</span><span class="k">const</span> <span class="k">void</span> <span class="o">*</span><span class="n">shmaddr</span><span class="p">);</span> <span class="c1">// 把内存段从晋城地址空间脱离</span>
</pre></div>


<div class="codehilite"><pre><span class="c1">// socket套接字</span>
<span class="p">#</span><span class="k">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">socket</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="k">int</span> <span class="n">socket</span><span class="p">(</span><span class="k">int</span> <span class="n">domain</span><span class="p">,</span> <span class="k">int</span> <span class="k">type</span><span class="p">,</span> <span class="k">int</span> <span class="n">protocol</span><span class="p">);</span> 
<span class="c1">// domain设置为AF_INET，type: SOCK_STREAM | SOCKDGRAM, protocol设为0</span>
<span class="k">int</span> <span class="k">bind</span><span class="p">(</span><span class="k">int</span> <span class="n">socket</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">address_len</span><span class="p">);</span>
<span class="c1">// 将socket绑定到本地计算机的一个端口上,address_len使用sizeof()获取</span>
<span class="k">int</span> <span class="n">connect</span><span class="p">(</span><span class="k">int</span> <span class="n">socket</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">address_len</span><span class="p">);</span> <span class="c1">// 连接</span>
<span class="k">int</span> <span class="n">listen</span><span class="p">(</span><span class="k">int</span> <span class="n">socket</span><span class="p">,</span> <span class="k">int</span> <span class="n">backlog</span><span class="p">);</span> <span class="c1">// 侦听，backlog:允许进入连接的个数</span>
<span class="k">int</span> <span class="n">accept</span><span class="p">(</span><span class="k">int</span> <span class="n">socket</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="o">*</span><span class="n">address_len</span><span class="p">);</span> <span class="c1">// 处理连接</span>
<span class="k">int</span> <span class="n">send</span><span class="p">(</span><span class="k">int</span> <span class="n">socket</span><span class="p">,</span> <span class="k">const</span> <span class="k">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="k">int</span> <span class="n">flags</span><span class="p">);</span> <span class="c1">// 发送数据</span>
<span class="k">int</span> <span class="n">recv</span><span class="p">(</span><span class="k">int</span> <span class="n">socket</span><span class="p">,</span> <span class="k">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="k">int</span> <span class="n">flags</span><span class="p">);</span> <span class="c1">// 接收数据</span>
</pre></div>


<h2>项目开发</h2>
<p>小组选择了聊天软件项目。</p>
<h3>需求分析阶段</h3>
<p>第一天完成了软件需求分析，产生了需求分析矩阵。大体分成服务器端和客户端。小组人员分为服务器编程人员，客户端编程人员还有UI设计人员。个人在项目中参与讨论需求，之后完成了对需求矩阵的评审。</p>
<h3>概要设计阶段</h3>
<p>进入概要设计阶段，产生了概要设计文档。主要对模块，函数接口等进行设计。系统模块图如下：
<img alt="概要设计结构图" src="http://jinjaysnow.github.io/images/design.png" />
作为评审负责人，我主要完成了概要设计文档的评审工作，写作了概要设计评审记录。此外，对设计中的技术点进行调查分析，主要包括QT的网络库使用、QT文件配置和Redis数据库的使用。</p>
<h3>编码阶段</h3>
<p>与另一名小组成员负责服务器端程序编写。个人主要完成 SQLite3和 Redis数据库相关代码编写。将数据库相关代码封装成概要设计相关接口。</p>
<div class="codehilite"><pre><span class="c1">// 使用hiredis与Redis数据库交互</span>
<span class="n">redisContext</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">redisConnect</span><span class="p">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="mh">6379</span><span class="p">);</span>  <span class="c1">// 连接本地Redis数据库</span>
<span class="n">redisReply</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">redisReply</span> <span class="o">*</span><span class="p">)</span><span class="n">redisCommand</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span> <span class="c1">// 执行并返回结果</span>
<span class="n">freeReplyObject</span><span class="p">(</span><span class="n">r</span><span class="p">);</span> <span class="c1">// 使用完结果后需要释放对象占用的空间</span>
<span class="n">redisFree</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>       <span class="c1">// 释放连接</span>
<span class="c1">// SQLite3</span>
<span class="n">Sqlite3</span> <span class="o">*</span><span class="n">db</span> <span class="o">=</span> <span class="no">NULL</span><span class="p">;</span> <span class="c1">// 定义一个数据对象</span>
<span class="k">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlite3_open</span><span class="p">(</span><span class="s">&quot;test.db&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db</span><span class="p">);</span> <span class="c1">// 打开数据库</span>
<span class="k">int</span> <span class="n">sqlite3_exec</span><span class="p">(</span><span class="n">sqlite3</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">sql</span><span class="p">,</span> <span class="k">int</span><span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">void</span><span class="o">*</span><span class="p">,</span><span class="k">int</span><span class="p">,</span><span class="n">char</span><span class="o">**</span><span class="p">,</span><span class="n">char</span><span class="o">**</span><span class="p">),</span> <span class="k">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span><span class="n">errmsg</span> <span class="p">);</span>   <span class="c1">// 执行语句</span>
</pre></div>


<p>编码阶段结束后，个人完成了代码评审，写作了代码评审记录。</p>
<h3>测试阶段</h3>
<p>测试阶段先由其他队员完成了测试用例的设计。个人对测试用例进行了评审，写作了测试用例评审记录。然后小组成员完成了测试，产生了系统测试报告。最后对系统测试报告进行评审。</p>
<h3>项目展示</h3>
<p>由于时间较紧，最后的软件并没有完成所有需求。没有群聊天，没有文件发送，客户端没有聊天记录保存与查询...但是软件的基本聊天功能实现了，还可以发送表情，发送图片，支持中文。</p>
<h1>在实习中收获最大与体会最深的内容</h1>
<p>不到一个月的时间，总感觉时间太短。可能是因为是实习生，在公司并没有加班什么的，朝九晚五的生活过得也还不错，有很多自己可以支配的时间。  </p>
<p>对于团队项目开发的感受是，在整个实习过程中，网络访问受到限制，只能通过设置网络代理打开百度网页，查看搜索资料内容也必须使用百度快照，感觉略麻烦。不过这样带来的好处是很多问题都是自己一步一步思考清楚后解决的，遇到不会的也是尽量去看文档（尽管大部分文档是英文的，看不太懂- -），而不是通过搜索引擎搜索到相应代码后复制粘贴。实习完后，感觉自己的能力有提升，尤其是看英文文档的能力。  </p>
<p>此外，感触很深的是项目开发过程中，一定要把设计文档写好，尤其是软件模块接口，因为文档是不同模块的编写者之间相互交流的蓝本，这次项目进度落后便是因为客户端与服务器交互的很多接口定义不是很好，双方对接口的理解也有一定的差异。最终项目的服务器端完成了大部分功能，而客户端没能跟上进度很好的完成所有需求，这是一件令人遗憾的事。</p>
<h1>对实习工作的改进意见</h1>
<ol>
<li>实习能够安排达到一个月的时间。</li>
<li>对公司文化并没有太多接触，如果公司能够让学员们与正式员工多接触，多参与到他们的项目讨论中更有益于了解软件公司项目运作过程。</li>
<li>因为软件学院的实习（应该叫做实训）与其他学院不同，实训并没有见识到很多实际的问题，都是一些自己在学校里做项目能够遇到的，如果能够接触到工业界的项目肯定很有意义。比如服务器访问量达到百万级的应用、分布式计算程序设计等等。</li>
</ol>
  	<div class="date">2014-08-22 23:11:34</div>
  </body>
</html>